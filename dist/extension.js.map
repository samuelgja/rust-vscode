{
  "version": 3,
  "sources": ["../src/extension.ts", "../src/features/tests/index.ts", "../node_modules/smol-toml/dist/error.js", "../node_modules/smol-toml/dist/util.js", "../node_modules/smol-toml/dist/date.js", "../node_modules/smol-toml/dist/primitive.js", "../node_modules/smol-toml/dist/extract.js", "../node_modules/smol-toml/dist/struct.js", "../node_modules/smol-toml/dist/parse.js"],
  "sourcesContent": ["import * as vscode from \"vscode\";\nimport { registerTestRunner, registerTestCodeLens } from \"./features/tests\";\n\nexport function activate(context: vscode.ExtensionContext) {\n  registerTestRunner(context);\n  registerTestCodeLens(context);\n}\n\nexport function deactivate() {}\n", "import * as vscode from \"vscode\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport { parse } from \"smol-toml\";\n\n/* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n\ninterface TestInfo {\n  name: string;\n  range: vscode.Range;\n}\n\n/** Find all #[test]-annotated (incl. parameterised) functions, incl. async */\nfunction findTests(doc: vscode.TextDocument): TestInfo[] {\n  const lines = doc.getText().split(/\\r?\\n/);\n  const tests: TestInfo[] = [];\n\n  const attrRe = /^\\s*#\\[\\s*(?:[\\w:]+::)*test(?:\\([^\\]]*\\))?\\]\\s*$/;\n  const fnRe = /^\\s*(?:async\\s+)?fn\\s+(\\w+)/;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (/^\\s*\\/\\//.test(line) || !attrRe.test(line)) continue;\n\n    for (let j = i + 1; j < Math.min(i + 6, lines.length); j++) {\n      const m = fnRe.exec(lines[j]);\n      if (m) {\n        const name = m[1];\n        const start = doc.positionAt(\n          lines.slice(0, i).join(\"\\n\").length + (i ? 1 : 0)\n        );\n        const end = doc.positionAt(lines.slice(0, j + 1).join(\"\\n\").length);\n        tests.push({ name, range: new vscode.Range(start, end) });\n        break;\n      }\n    }\n  }\n  return tests;\n}\n\nclass TestCodeLensProvider implements vscode.CodeLensProvider {\n  provideCodeLenses(doc: vscode.TextDocument): vscode.CodeLens[] {\n    const actions: Array<[string, string]> = [\n      [\"Run Test\", \"extension.rust.tests.runTest\"],\n      [\"Watch Test\", \"extension.rust.tests.watchTest\"],\n      [\"Run Release Test\", \"extension.rust.tests.runReleaseTest\"],\n      [\"Watch Release Test\", \"extension.rust.tests.watchReleaseTest\"],\n      [\"Profile Test (Samply)\", \"extension.rust.tests.profileTest\"],\n    ];\n    return findTests(doc).flatMap(({ name, range }) =>\n      actions.map(\n        ([title, cmd]) =>\n          new vscode.CodeLens(range, {\n            title,\n            command: cmd,\n            arguments: [doc.fileName, name],\n          })\n      )\n    );\n  }\n}\n\nexport function registerTestCodeLens(ctx: vscode.ExtensionContext) {\n  ctx.subscriptions.push(\n    vscode.languages.registerCodeLensProvider(\n      { scheme: \"file\", pattern: \"**/*.rs\", language: \"rust\" },\n      new TestCodeLensProvider()\n    )\n  );\n}\n\n/* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 runner core \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n\nlet activeTerminal: vscode.Terminal | null = null;\n\n/** All info needed to build a cargo test command */\ninterface CargoInfo {\n  packageName?: string;\n  targetType: \"bin\" | \"lib\";\n  targetName: string;\n  cargoTomlDir: string;\n  testFunctionFullNames: Record<string, string>;\n}\n\n/**\n * Build the `cargo test \u2026 -- <args>` part.\n * Shared by normal run/watch and Samply profiling.\n */\nfunction buildCargoTestCommand(\n  info: CargoInfo,\n  opts: {\n    testName?: string;\n    release: boolean;\n    extraArgs?: string; // e.g. custom `--features`\n  }\n): string {\n  const cfg = vscode.workspace.getConfiguration(\"rust.tests\");\n  let cmd = cfg.get<string>(\"customScript\", \"cargo test\").trim();\n\n  const workspaceRoot =\n    vscode.workspace.workspaceFolders?.[0]?.uri.fsPath ?? \"\";\n\n  if (info.cargoTomlDir !== workspaceRoot) {\n    cmd += ` --manifest-path \"${path.join(info.cargoTomlDir, \"Cargo.toml\")}\"`;\n  }\n  if (info.packageName) cmd += ` --package ${info.packageName}`;\n  if (info.targetType === \"bin\") cmd += ` --bin ${info.targetName}`;\n  else cmd += ` --lib`;\n  if (opts.release) cmd += \" --release\";\n\n  if (opts.extraArgs?.trim()) cmd += ` ${opts.extraArgs.trim()}`;\n\n  // test-specific arguments\n  let testArgs = \"--nocapture --exact\";\n  if (opts.testName) {\n    const full = info.testFunctionFullNames[opts.testName] ?? opts.testName;\n    testArgs += ` ${full} --show-output`;\n  }\n  return `${cmd} -- ${testArgs}`;\n}\n\n/**\n * Ensure there\u2019s a visible terminal named \u201CCargo Test Runner\u201D\n * (past one is disposed each invocation).\n */\nfunction createTerminal(name: string): vscode.Terminal {\n  activeTerminal?.dispose();\n  activeTerminal = vscode.window.createTerminal(name);\n  activeTerminal.show();\n  return activeTerminal;\n}\n\n/* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 cargo.toml parsing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n\nasync function getCargoInfo(filePath: string): Promise<CargoInfo | null> {\n  // Ascend tree to locate Cargo.toml\n  let dir = path.dirname(filePath);\n  let tomlPath = \"\";\n  while (true) {\n    const p = path.join(dir, \"Cargo.toml\");\n    if (fs.existsSync(p)) {\n      tomlPath = p;\n      break;\n    }\n    const up = path.dirname(dir);\n    if (up === dir) break;\n    dir = up;\n  }\n  if (!tomlPath) return null;\n\n  const cargoDir = path.dirname(tomlPath);\n  const cfg: Record<string, any> = parse(fs.readFileSync(tomlPath, \"utf8\"));\n  const pkgName: string | undefined = cfg.package?.name;\n  const hasLib = !!cfg.lib || fs.existsSync(path.join(cargoDir, \"src/lib.rs\"));\n\n  // full qualified test names\n  const testFunctionFullNames = collectTestFunctionFullNames(\n    filePath,\n    cargoDir\n  );\n\n  // Determine binary / lib target\n  let targetType: \"bin\" | \"lib\" = hasLib ? \"lib\" : \"bin\";\n  let targetName = pkgName!;\n  const bins: Array<{ name: string; path: string }> = [];\n\n  if (Array.isArray(cfg.bin)) {\n    cfg.bin.forEach((b: any) =>\n      bins.push({\n        name: b.name ?? pkgName!,\n        path: path.join(cargoDir, b.path ?? \"src/main.rs\"),\n      })\n    );\n  } else if (fs.existsSync(path.join(cargoDir, \"src/main.rs\"))) {\n    bins.push({ name: pkgName!, path: path.join(cargoDir, \"src/main.rs\") });\n  }\n\n  const rel = path.relative(cargoDir, filePath).replace(/\\\\/g, \"/\");\n  for (const b of bins) {\n    const bRel = path.relative(cargoDir, b.path).replace(/\\\\/g, \"/\");\n    if (rel === bRel || rel.startsWith(\"src/\")) {\n      targetType = \"bin\";\n      targetName = b.name;\n      break;\n    }\n  }\n\n  return {\n    packageName: pkgName,\n    targetType,\n    targetName,\n    cargoTomlDir: cargoDir,\n    testFunctionFullNames,\n  };\n}\n\nfunction collectTestFunctionFullNames(\n  filePath: string,\n  cargoDir: string\n): Record<string, string> {\n  const lines = fs.readFileSync(filePath, \"utf8\").split(/\\r?\\n/);\n  const attrRe = /^\\s*#\\[\\s*(?:[\\w:]+::)*test(?:\\([^\\]]*\\))?\\]\\s*$/;\n\n  const moduleStack: Array<{ name: string; braceLevel: number }> = [];\n  const srcDir = path.join(cargoDir, \"src\");\n  const relPath = path.relative(srcDir, filePath).replace(/\\\\/g, \"/\");\n  if (!relPath.startsWith(\"..\")) {\n    relPath\n      .replace(/\\.rs$/, \"\")\n      .replace(/\\/mod$/, \"\")\n      .replace(/\\//g, \"::\")\n      .split(\"::\")\n      .filter(Boolean)\n      .forEach((n) => moduleStack.push({ name: n, braceLevel: -1 }));\n  }\n\n  const result: Record<string, string> = {};\n  let brace = 0;\n\n  lines.forEach((line, idx) => {\n    const modM = line.match(/^\\s*mod\\s+(\\w+)\\s*\\{/);\n    if (modM) moduleStack.push({ name: modM[1], braceLevel: brace });\n\n    if (attrRe.test(line)) {\n      let j = idx + 1;\n      while (j < lines.length && lines[j].trim() === \"\") j++;\n      const fnM = lines[j]?.match(/^\\s*(?:async\\s+)?fn\\s+(\\w+)/);\n      if (fnM) {\n        const full = moduleStack\n          .map((m) => m.name)\n          .filter(Boolean)\n          .join(\"::\");\n        result[fnM[1]] = full ? `${full}::${fnM[1]}` : fnM[1];\n      }\n    }\n\n    brace += (line.match(/{/g) || []).length;\n    brace -= (line.match(/}/g) || []).length;\n    while (\n      moduleStack.length &&\n      moduleStack[moduleStack.length - 1].braceLevel >= 0 &&\n      brace < moduleStack[moduleStack.length - 1].braceLevel + 1\n    ) {\n      moduleStack.pop();\n    }\n  });\n  return result;\n}\n\n/* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 command impls \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n\nasync function runTestCommand(\n  fileName?: string,\n  testName?: string,\n  watch = false,\n  release = false\n) {\n  if (!fileName) fileName = vscode.window.activeTextEditor?.document.fileName;\n  if (!fileName) return;\n\n  const info = await getCargoInfo(fileName);\n  if (!info) {\n    vscode.window.showErrorMessage(\"Could not find Cargo.toml\");\n    return;\n  }\n\n  const cargoCmd = buildCargoTestCommand(info, { testName, release });\n  const term = createTerminal(\"Cargo Test Runner\");\n\n  if (watch) {\n    const core = cargoCmd.replace(/^cargo\\s+/, \"\");\n    const workspaceRoot =\n      vscode.workspace.workspaceFolders?.[0]?.uri.fsPath ?? \"\";\n    const chdir =\n      info.cargoTomlDir !== workspaceRoot\n        ? `cd \"${info.cargoTomlDir}\" && `\n        : \"\";\n    term.sendText(`${chdir}cargo watch -x \"${core}\" -d 0.1`, true);\n  } else {\n    term.sendText(cargoCmd, true);\n  }\n}\n\nasync function runProfileCommand(fileName?: string, testName?: string) {\n  if (!fileName) fileName = vscode.window.activeTextEditor?.document.fileName;\n  if (!fileName) return;\n\n  const info = await getCargoInfo(fileName);\n  if (!info) {\n    vscode.window.showErrorMessage(\"Could not find Cargo.toml\");\n    return;\n  }\n\n  const base = buildCargoTestCommand(info, { testName, release: true });\n  const samplyCmd = vscode.workspace\n    .getConfiguration(\"rust.tests\")\n    .get<string>(\"samplyScript\", \"samply record\")\n    .trim();\n\n  const term = createTerminal(\"Cargo Test Profiler\");\n  term.sendText(`${samplyCmd} ${base}`, true);\n}\n\n/* \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 registration \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n\nexport function registerTestRunner(ctx: vscode.ExtensionContext) {\n  ctx.subscriptions.push(\n    vscode.commands.registerCommand(\"extension.rust.tests.runTest\", (f, t) =>\n      runTestCommand(f, t, false, false)\n    ),\n    vscode.commands.registerCommand(\"extension.rust.tests.watchTest\", (f, t) =>\n      runTestCommand(f, t, true, false)\n    ),\n    vscode.commands.registerCommand(\n      \"extension.rust.tests.runReleaseTest\",\n      (f, t) => runTestCommand(f, t, false, true)\n    ),\n    vscode.commands.registerCommand(\n      \"extension.rust.tests.watchReleaseTest\",\n      (f, t) => runTestCommand(f, t, true, true)\n    ),\n    vscode.commands.registerCommand(\n      \"extension.rust.tests.profileTest\",\n      (f, t) => runProfileCommand(f, t)\n    )\n  );\n}\n", "/*!\n * Copyright (c) Squirrel Chat et al., All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holder nor the names of its contributors\n *    may be used to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nfunction getLineColFromPtr(string, ptr) {\n    let lines = string.slice(0, ptr).split(/\\r\\n|\\n|\\r/g);\n    return [lines.length, lines.pop().length + 1];\n}\nfunction makeCodeBlock(string, line, column) {\n    let lines = string.split(/\\r\\n|\\n|\\r/g);\n    let codeblock = '';\n    let numberLen = (Math.log10(line + 1) | 0) + 1;\n    for (let i = line - 1; i <= line + 1; i++) {\n        let l = lines[i - 1];\n        if (!l)\n            continue;\n        codeblock += i.toString().padEnd(numberLen, ' ');\n        codeblock += ':  ';\n        codeblock += l;\n        codeblock += '\\n';\n        if (i === line) {\n            codeblock += ' '.repeat(numberLen + column + 2);\n            codeblock += '^\\n';\n        }\n    }\n    return codeblock;\n}\nexport class TomlError extends Error {\n    line;\n    column;\n    codeblock;\n    constructor(message, options) {\n        const [line, column] = getLineColFromPtr(options.toml, options.ptr);\n        const codeblock = makeCodeBlock(options.toml, line, column);\n        super(`Invalid TOML document: ${message}\\n\\n${codeblock}`, options);\n        this.line = line;\n        this.column = column;\n        this.codeblock = codeblock;\n    }\n}\n", "/*!\n * Copyright (c) Squirrel Chat et al., All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holder nor the names of its contributors\n *    may be used to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nimport { TomlError } from './error.js';\nfunction isEscaped(str, ptr) {\n    let i = 0;\n    while (str[ptr - ++i] === '\\\\')\n        ;\n    return --i && (i % 2);\n}\nexport function indexOfNewline(str, start = 0, end = str.length) {\n    let idx = str.indexOf('\\n', start);\n    if (str[idx - 1] === '\\r')\n        idx--;\n    return idx <= end ? idx : -1;\n}\nexport function skipComment(str, ptr) {\n    for (let i = ptr; i < str.length; i++) {\n        let c = str[i];\n        if (c === '\\n')\n            return i;\n        if (c === '\\r' && str[i + 1] === '\\n')\n            return i + 1;\n        if ((c < '\\x20' && c !== '\\t') || c === '\\x7f') {\n            throw new TomlError('control characters are not allowed in comments', {\n                toml: str,\n                ptr: ptr,\n            });\n        }\n    }\n    return str.length;\n}\nexport function skipVoid(str, ptr, banNewLines, banComments) {\n    let c;\n    while ((c = str[ptr]) === ' ' || c === '\\t' || (!banNewLines && (c === '\\n' || c === '\\r' && str[ptr + 1] === '\\n')))\n        ptr++;\n    return banComments || c !== '#'\n        ? ptr\n        : skipVoid(str, skipComment(str, ptr), banNewLines);\n}\nexport function skipUntil(str, ptr, sep, end, banNewLines = false) {\n    if (!end) {\n        ptr = indexOfNewline(str, ptr);\n        return ptr < 0 ? str.length : ptr;\n    }\n    for (let i = ptr; i < str.length; i++) {\n        let c = str[i];\n        if (c === '#') {\n            i = indexOfNewline(str, i);\n        }\n        else if (c === sep) {\n            return i + 1;\n        }\n        else if (c === end || (banNewLines && (c === '\\n' || (c === '\\r' && str[i + 1] === '\\n')))) {\n            return i;\n        }\n    }\n    throw new TomlError('cannot find end of structure', {\n        toml: str,\n        ptr: ptr\n    });\n}\nexport function getStringEnd(str, seek) {\n    let first = str[seek];\n    let target = first === str[seek + 1] && str[seek + 1] === str[seek + 2]\n        ? str.slice(seek, seek + 3)\n        : first;\n    seek += target.length - 1;\n    do\n        seek = str.indexOf(target, ++seek);\n    while (seek > -1 && first !== \"'\" && isEscaped(str, seek));\n    if (seek > -1) {\n        seek += target.length;\n        if (target.length > 1) {\n            if (str[seek] === first)\n                seek++;\n            if (str[seek] === first)\n                seek++;\n        }\n    }\n    return seek;\n}\n", "/*!\n * Copyright (c) Squirrel Chat et al., All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holder nor the names of its contributors\n *    may be used to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nlet DATE_TIME_RE = /^(\\d{4}-\\d{2}-\\d{2})?[T ]?(?:(\\d{2}):\\d{2}:\\d{2}(?:\\.\\d+)?)?(Z|[-+]\\d{2}:\\d{2})?$/i;\nexport class TomlDate extends Date {\n    #hasDate = false;\n    #hasTime = false;\n    #offset = null;\n    constructor(date) {\n        let hasDate = true;\n        let hasTime = true;\n        let offset = 'Z';\n        if (typeof date === 'string') {\n            let match = date.match(DATE_TIME_RE);\n            if (match) {\n                if (!match[1]) {\n                    hasDate = false;\n                    date = `0000-01-01T${date}`;\n                }\n                hasTime = !!match[2];\n                // Make sure to use T instead of a space. Breaks in case of extreme values otherwise.\n                hasTime && date[10] === ' ' && (date = date.replace(' ', 'T'));\n                // Do not allow rollover hours.\n                if (match[2] && +match[2] > 23) {\n                    date = '';\n                }\n                else {\n                    offset = match[3] || null;\n                    date = date.toUpperCase();\n                    if (!offset && hasTime)\n                        date += 'Z';\n                }\n            }\n            else {\n                date = '';\n            }\n        }\n        super(date);\n        if (!isNaN(this.getTime())) {\n            this.#hasDate = hasDate;\n            this.#hasTime = hasTime;\n            this.#offset = offset;\n        }\n    }\n    isDateTime() {\n        return this.#hasDate && this.#hasTime;\n    }\n    isLocal() {\n        return !this.#hasDate || !this.#hasTime || !this.#offset;\n    }\n    isDate() {\n        return this.#hasDate && !this.#hasTime;\n    }\n    isTime() {\n        return this.#hasTime && !this.#hasDate;\n    }\n    isValid() {\n        return this.#hasDate || this.#hasTime;\n    }\n    toISOString() {\n        let iso = super.toISOString();\n        // Local Date\n        if (this.isDate())\n            return iso.slice(0, 10);\n        // Local Time\n        if (this.isTime())\n            return iso.slice(11, 23);\n        // Local DateTime\n        if (this.#offset === null)\n            return iso.slice(0, -1);\n        // Offset DateTime\n        if (this.#offset === 'Z')\n            return iso;\n        // This part is quite annoying: JS strips the original timezone from the ISO string representation\n        // Instead of using a \"modified\" date and \"Z\", we restore the representation \"as authored\"\n        let offset = (+(this.#offset.slice(1, 3)) * 60) + +(this.#offset.slice(4, 6));\n        offset = this.#offset[0] === '-' ? offset : -offset;\n        let offsetDate = new Date(this.getTime() - (offset * 60e3));\n        return offsetDate.toISOString().slice(0, -1) + this.#offset;\n    }\n    static wrapAsOffsetDateTime(jsDate, offset = 'Z') {\n        let date = new TomlDate(jsDate);\n        date.#offset = offset;\n        return date;\n    }\n    static wrapAsLocalDateTime(jsDate) {\n        let date = new TomlDate(jsDate);\n        date.#offset = null;\n        return date;\n    }\n    static wrapAsLocalDate(jsDate) {\n        let date = new TomlDate(jsDate);\n        date.#hasTime = false;\n        date.#offset = null;\n        return date;\n    }\n    static wrapAsLocalTime(jsDate) {\n        let date = new TomlDate(jsDate);\n        date.#hasDate = false;\n        date.#offset = null;\n        return date;\n    }\n}\n", "/*!\n * Copyright (c) Squirrel Chat et al., All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holder nor the names of its contributors\n *    may be used to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nimport { skipVoid } from './util.js';\nimport { TomlDate } from './date.js';\nimport { TomlError } from './error.js';\nlet INT_REGEX = /^((0x[0-9a-fA-F](_?[0-9a-fA-F])*)|(([+-]|0[ob])?\\d(_?\\d)*))$/;\nlet FLOAT_REGEX = /^[+-]?\\d(_?\\d)*(\\.\\d(_?\\d)*)?([eE][+-]?\\d(_?\\d)*)?$/;\nlet LEADING_ZERO = /^[+-]?0[0-9_]/;\nlet ESCAPE_REGEX = /^[0-9a-f]{4,8}$/i;\nlet ESC_MAP = {\n    b: '\\b',\n    t: '\\t',\n    n: '\\n',\n    f: '\\f',\n    r: '\\r',\n    '\"': '\"',\n    '\\\\': '\\\\',\n};\nexport function parseString(str, ptr = 0, endPtr = str.length) {\n    let isLiteral = str[ptr] === '\\'';\n    let isMultiline = str[ptr++] === str[ptr] && str[ptr] === str[ptr + 1];\n    if (isMultiline) {\n        endPtr -= 2;\n        if (str[ptr += 2] === '\\r')\n            ptr++;\n        if (str[ptr] === '\\n')\n            ptr++;\n    }\n    let tmp = 0;\n    let isEscape;\n    let parsed = '';\n    let sliceStart = ptr;\n    while (ptr < endPtr - 1) {\n        let c = str[ptr++];\n        if (c === '\\n' || (c === '\\r' && str[ptr] === '\\n')) {\n            if (!isMultiline) {\n                throw new TomlError('newlines are not allowed in strings', {\n                    toml: str,\n                    ptr: ptr - 1,\n                });\n            }\n        }\n        else if ((c < '\\x20' && c !== '\\t') || c === '\\x7f') {\n            throw new TomlError('control characters are not allowed in strings', {\n                toml: str,\n                ptr: ptr - 1,\n            });\n        }\n        if (isEscape) {\n            isEscape = false;\n            if (c === 'u' || c === 'U') {\n                // Unicode escape\n                let code = str.slice(ptr, (ptr += (c === 'u' ? 4 : 8)));\n                if (!ESCAPE_REGEX.test(code)) {\n                    throw new TomlError('invalid unicode escape', {\n                        toml: str,\n                        ptr: tmp,\n                    });\n                }\n                try {\n                    parsed += String.fromCodePoint(parseInt(code, 16));\n                }\n                catch {\n                    throw new TomlError('invalid unicode escape', {\n                        toml: str,\n                        ptr: tmp,\n                    });\n                }\n            }\n            else if (isMultiline && (c === '\\n' || c === ' ' || c === '\\t' || c === '\\r')) {\n                // Multiline escape\n                ptr = skipVoid(str, ptr - 1, true);\n                if (str[ptr] !== '\\n' && str[ptr] !== '\\r') {\n                    throw new TomlError('invalid escape: only line-ending whitespace may be escaped', {\n                        toml: str,\n                        ptr: tmp,\n                    });\n                }\n                ptr = skipVoid(str, ptr);\n            }\n            else if (c in ESC_MAP) {\n                // Classic escape\n                parsed += ESC_MAP[c];\n            }\n            else {\n                throw new TomlError('unrecognized escape sequence', {\n                    toml: str,\n                    ptr: tmp,\n                });\n            }\n            sliceStart = ptr;\n        }\n        else if (!isLiteral && c === '\\\\') {\n            tmp = ptr - 1;\n            isEscape = true;\n            parsed += str.slice(sliceStart, tmp);\n        }\n    }\n    return parsed + str.slice(sliceStart, endPtr - 1);\n}\nexport function parseValue(value, toml, ptr, integersAsBigInt) {\n    // Constant values\n    if (value === 'true')\n        return true;\n    if (value === 'false')\n        return false;\n    if (value === '-inf')\n        return -Infinity;\n    if (value === 'inf' || value === '+inf')\n        return Infinity;\n    if (value === 'nan' || value === '+nan' || value === '-nan')\n        return NaN;\n    // Avoid FP representation of -0\n    if (value === '-0')\n        return integersAsBigInt ? 0n : 0;\n    // Numbers\n    let isInt = INT_REGEX.test(value);\n    if (isInt || FLOAT_REGEX.test(value)) {\n        if (LEADING_ZERO.test(value)) {\n            throw new TomlError('leading zeroes are not allowed', {\n                toml: toml,\n                ptr: ptr,\n            });\n        }\n        value = value.replace(/_/g, '');\n        let numeric = +value;\n        if (isNaN(numeric)) {\n            throw new TomlError('invalid number', {\n                toml: toml,\n                ptr: ptr,\n            });\n        }\n        if (isInt) {\n            if ((isInt = !Number.isSafeInteger(numeric)) && !integersAsBigInt) {\n                throw new TomlError('integer value cannot be represented losslessly', {\n                    toml: toml,\n                    ptr: ptr,\n                });\n            }\n            if (isInt || integersAsBigInt === true)\n                numeric = BigInt(value);\n        }\n        return numeric;\n    }\n    const date = new TomlDate(value);\n    if (!date.isValid()) {\n        throw new TomlError('invalid value', {\n            toml: toml,\n            ptr: ptr,\n        });\n    }\n    return date;\n}\n", "/*!\n * Copyright (c) Squirrel Chat et al., All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holder nor the names of its contributors\n *    may be used to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nimport { parseString, parseValue } from './primitive.js';\nimport { parseArray, parseInlineTable } from './struct.js';\nimport { indexOfNewline, skipVoid, skipUntil, skipComment, getStringEnd } from './util.js';\nimport { TomlError } from './error.js';\nfunction sliceAndTrimEndOf(str, startPtr, endPtr, allowNewLines) {\n    let value = str.slice(startPtr, endPtr);\n    let commentIdx = value.indexOf('#');\n    if (commentIdx > -1) {\n        // The call to skipComment allows to \"validate\" the comment\n        // (absence of control characters)\n        skipComment(str, commentIdx);\n        value = value.slice(0, commentIdx);\n    }\n    let trimmed = value.trimEnd();\n    if (!allowNewLines) {\n        let newlineIdx = value.indexOf('\\n', trimmed.length);\n        if (newlineIdx > -1) {\n            throw new TomlError('newlines are not allowed in inline tables', {\n                toml: str,\n                ptr: startPtr + newlineIdx\n            });\n        }\n    }\n    return [trimmed, commentIdx];\n}\nexport function extractValue(str, ptr, end, depth, integersAsBigInt) {\n    if (depth === 0) {\n        throw new TomlError('document contains excessively nested structures. aborting.', {\n            toml: str,\n            ptr: ptr\n        });\n    }\n    let c = str[ptr];\n    if (c === '[' || c === '{') {\n        let [value, endPtr] = c === '['\n            ? parseArray(str, ptr, depth, integersAsBigInt)\n            : parseInlineTable(str, ptr, depth, integersAsBigInt);\n        let newPtr = end ? skipUntil(str, endPtr, ',', end) : endPtr;\n        if (endPtr - newPtr && end === '}') {\n            let nextNewLine = indexOfNewline(str, endPtr, newPtr);\n            if (nextNewLine > -1) {\n                throw new TomlError('newlines are not allowed in inline tables', {\n                    toml: str,\n                    ptr: nextNewLine\n                });\n            }\n        }\n        return [value, newPtr];\n    }\n    let endPtr;\n    if (c === '\"' || c === \"'\") {\n        endPtr = getStringEnd(str, ptr);\n        let parsed = parseString(str, ptr, endPtr);\n        if (end) {\n            endPtr = skipVoid(str, endPtr, end !== ']');\n            if (str[endPtr] && str[endPtr] !== ',' && str[endPtr] !== end && str[endPtr] !== '\\n' && str[endPtr] !== '\\r') {\n                throw new TomlError('unexpected character encountered', {\n                    toml: str,\n                    ptr: endPtr,\n                });\n            }\n            endPtr += (+(str[endPtr] === ','));\n        }\n        return [parsed, endPtr];\n    }\n    endPtr = skipUntil(str, ptr, ',', end);\n    let slice = sliceAndTrimEndOf(str, ptr, endPtr - (+(str[endPtr - 1] === ',')), end === ']');\n    if (!slice[0]) {\n        throw new TomlError('incomplete key-value declaration: no value specified', {\n            toml: str,\n            ptr: ptr\n        });\n    }\n    if (end && slice[1] > -1) {\n        endPtr = skipVoid(str, ptr + slice[1]);\n        endPtr += +(str[endPtr] === ',');\n    }\n    return [\n        parseValue(slice[0], str, ptr, integersAsBigInt),\n        endPtr,\n    ];\n}\n", "/*!\n * Copyright (c) Squirrel Chat et al., All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holder nor the names of its contributors\n *    may be used to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nimport { parseString } from './primitive.js';\nimport { extractValue } from './extract.js';\nimport { getStringEnd, indexOfNewline, skipComment, skipVoid } from './util.js';\nimport { TomlError } from './error.js';\nlet KEY_PART_RE = /^[a-zA-Z0-9-_]+[ \\t]*$/;\nexport function parseKey(str, ptr, end = '=') {\n    let dot = ptr - 1;\n    let parsed = [];\n    let endPtr = str.indexOf(end, ptr);\n    if (endPtr < 0) {\n        throw new TomlError('incomplete key-value: cannot find end of key', {\n            toml: str,\n            ptr: ptr,\n        });\n    }\n    do {\n        let c = str[ptr = ++dot];\n        // If it's whitespace, ignore\n        if (c !== ' ' && c !== '\\t') {\n            // If it's a string\n            if (c === '\"' || c === '\\'') {\n                if (c === str[ptr + 1] && c === str[ptr + 2]) {\n                    throw new TomlError('multiline strings are not allowed in keys', {\n                        toml: str,\n                        ptr: ptr,\n                    });\n                }\n                let eos = getStringEnd(str, ptr);\n                if (eos < 0) {\n                    throw new TomlError('unfinished string encountered', {\n                        toml: str,\n                        ptr: ptr,\n                    });\n                }\n                dot = str.indexOf('.', eos);\n                let strEnd = str.slice(eos, dot < 0 || dot > endPtr ? endPtr : dot);\n                let newLine = indexOfNewline(strEnd);\n                if (newLine > -1) {\n                    throw new TomlError('newlines are not allowed in keys', {\n                        toml: str,\n                        ptr: ptr + dot + newLine,\n                    });\n                }\n                if (strEnd.trimStart()) {\n                    throw new TomlError('found extra tokens after the string part', {\n                        toml: str,\n                        ptr: eos,\n                    });\n                }\n                if (endPtr < eos) {\n                    endPtr = str.indexOf(end, eos);\n                    if (endPtr < 0) {\n                        throw new TomlError('incomplete key-value: cannot find end of key', {\n                            toml: str,\n                            ptr: ptr,\n                        });\n                    }\n                }\n                parsed.push(parseString(str, ptr, eos));\n            }\n            else {\n                // Normal raw key part consumption and validation\n                dot = str.indexOf('.', ptr);\n                let part = str.slice(ptr, dot < 0 || dot > endPtr ? endPtr : dot);\n                if (!KEY_PART_RE.test(part)) {\n                    throw new TomlError('only letter, numbers, dashes and underscores are allowed in keys', {\n                        toml: str,\n                        ptr: ptr,\n                    });\n                }\n                parsed.push(part.trimEnd());\n            }\n        }\n        // Until there's no more dot\n    } while (dot + 1 && dot < endPtr);\n    return [parsed, skipVoid(str, endPtr + 1, true, true)];\n}\nexport function parseInlineTable(str, ptr, depth, integersAsBigInt) {\n    let res = {};\n    let seen = new Set();\n    let c;\n    let comma = 0;\n    ptr++;\n    while ((c = str[ptr++]) !== '}' && c) {\n        let err = { toml: str, ptr: ptr - 1 };\n        if (c === '\\n') {\n            throw new TomlError('newlines are not allowed in inline tables', err);\n        }\n        else if (c === '#') {\n            throw new TomlError('inline tables cannot contain comments', err);\n        }\n        else if (c === ',') {\n            throw new TomlError('expected key-value, found comma', err);\n        }\n        else if (c !== ' ' && c !== '\\t') {\n            let k;\n            let t = res;\n            let hasOwn = false;\n            let [key, keyEndPtr] = parseKey(str, ptr - 1);\n            for (let i = 0; i < key.length; i++) {\n                if (i)\n                    t = hasOwn ? t[k] : (t[k] = {});\n                k = key[i];\n                if ((hasOwn = Object.hasOwn(t, k)) && (typeof t[k] !== 'object' || seen.has(t[k]))) {\n                    throw new TomlError('trying to redefine an already defined value', {\n                        toml: str,\n                        ptr: ptr,\n                    });\n                }\n                if (!hasOwn && k === '__proto__') {\n                    Object.defineProperty(t, k, { enumerable: true, configurable: true, writable: true });\n                }\n            }\n            if (hasOwn) {\n                throw new TomlError('trying to redefine an already defined value', {\n                    toml: str,\n                    ptr: ptr,\n                });\n            }\n            let [value, valueEndPtr] = extractValue(str, keyEndPtr, '}', depth - 1, integersAsBigInt);\n            seen.add(value);\n            t[k] = value;\n            ptr = valueEndPtr;\n            comma = str[ptr - 1] === ',' ? ptr - 1 : 0;\n        }\n    }\n    if (comma) {\n        throw new TomlError('trailing commas are not allowed in inline tables', {\n            toml: str,\n            ptr: comma,\n        });\n    }\n    if (!c) {\n        throw new TomlError('unfinished table encountered', {\n            toml: str,\n            ptr: ptr,\n        });\n    }\n    return [res, ptr];\n}\nexport function parseArray(str, ptr, depth, integersAsBigInt) {\n    let res = [];\n    let c;\n    ptr++;\n    while ((c = str[ptr++]) !== ']' && c) {\n        if (c === ',') {\n            throw new TomlError('expected value, found comma', {\n                toml: str,\n                ptr: ptr - 1,\n            });\n        }\n        else if (c === '#')\n            ptr = skipComment(str, ptr);\n        else if (c !== ' ' && c !== '\\t' && c !== '\\n' && c !== '\\r') {\n            let e = extractValue(str, ptr - 1, ']', depth - 1, integersAsBigInt);\n            res.push(e[0]);\n            ptr = e[1];\n        }\n    }\n    if (!c) {\n        throw new TomlError('unfinished array encountered', {\n            toml: str,\n            ptr: ptr,\n        });\n    }\n    return [res, ptr];\n}\n", "/*!\n * Copyright (c) Squirrel Chat et al., All rights reserved.\n * SPDX-License-Identifier: BSD-3-Clause\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holder nor the names of its contributors\n *    may be used to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nimport { parseKey } from './struct.js';\nimport { extractValue } from './extract.js';\nimport { skipVoid } from './util.js';\nimport { TomlError } from './error.js';\nfunction peekTable(key, table, meta, type) {\n    let t = table;\n    let m = meta;\n    let k;\n    let hasOwn = false;\n    let state;\n    for (let i = 0; i < key.length; i++) {\n        if (i) {\n            t = hasOwn ? t[k] : (t[k] = {});\n            m = (state = m[k]).c;\n            if (type === 0 /* Type.DOTTED */ && (state.t === 1 /* Type.EXPLICIT */ || state.t === 2 /* Type.ARRAY */)) {\n                return null;\n            }\n            if (state.t === 2 /* Type.ARRAY */) {\n                let l = t.length - 1;\n                t = t[l];\n                m = m[l].c;\n            }\n        }\n        k = key[i];\n        if ((hasOwn = Object.hasOwn(t, k)) && m[k]?.t === 0 /* Type.DOTTED */ && m[k]?.d) {\n            return null;\n        }\n        if (!hasOwn) {\n            if (k === '__proto__') {\n                Object.defineProperty(t, k, { enumerable: true, configurable: true, writable: true });\n                Object.defineProperty(m, k, { enumerable: true, configurable: true, writable: true });\n            }\n            m[k] = {\n                t: i < key.length - 1 && type === 2 /* Type.ARRAY */\n                    ? 3 /* Type.ARRAY_DOTTED */\n                    : type,\n                d: false,\n                i: 0,\n                c: {},\n            };\n        }\n    }\n    state = m[k];\n    if (state.t !== type && !(type === 1 /* Type.EXPLICIT */ && state.t === 3 /* Type.ARRAY_DOTTED */)) {\n        // Bad key type!\n        return null;\n    }\n    if (type === 2 /* Type.ARRAY */) {\n        if (!state.d) {\n            state.d = true;\n            t[k] = [];\n        }\n        t[k].push(t = {});\n        state.c[state.i++] = (state = { t: 1 /* Type.EXPLICIT */, d: false, i: 0, c: {} });\n    }\n    if (state.d) {\n        // Redefining a table!\n        return null;\n    }\n    state.d = true;\n    if (type === 1 /* Type.EXPLICIT */) {\n        t = hasOwn ? t[k] : (t[k] = {});\n    }\n    else if (type === 0 /* Type.DOTTED */ && hasOwn) {\n        return null;\n    }\n    return [k, t, state.c];\n}\nexport function parse(toml, { maxDepth = 1000, integersAsBigInt } = {}) {\n    let res = {};\n    let meta = {};\n    let tbl = res;\n    let m = meta;\n    for (let ptr = skipVoid(toml, 0); ptr < toml.length;) {\n        if (toml[ptr] === '[') {\n            let isTableArray = toml[++ptr] === '[';\n            let k = parseKey(toml, ptr += +isTableArray, ']');\n            if (isTableArray) {\n                if (toml[k[1] - 1] !== ']') {\n                    throw new TomlError('expected end of table declaration', {\n                        toml: toml,\n                        ptr: k[1] - 1,\n                    });\n                }\n                k[1]++;\n            }\n            let p = peekTable(k[0], res, meta, isTableArray ? 2 /* Type.ARRAY */ : 1 /* Type.EXPLICIT */);\n            if (!p) {\n                throw new TomlError('trying to redefine an already defined table or value', {\n                    toml: toml,\n                    ptr: ptr,\n                });\n            }\n            m = p[2];\n            tbl = p[1];\n            ptr = k[1];\n        }\n        else {\n            let k = parseKey(toml, ptr);\n            let p = peekTable(k[0], tbl, m, 0 /* Type.DOTTED */);\n            if (!p) {\n                throw new TomlError('trying to redefine an already defined table or value', {\n                    toml: toml,\n                    ptr: ptr,\n                });\n            }\n            let v = extractValue(toml, k[1], void 0, maxDepth, integersAsBigInt);\n            p[1][p[0]] = v[0];\n            ptr = v[1];\n        }\n        ptr = skipVoid(toml, ptr, true);\n        if (toml[ptr] && toml[ptr] !== '\\n' && toml[ptr] !== '\\r') {\n            throw new TomlError('each key-value declaration must be followed by an end-of-line', {\n                toml: toml,\n                ptr: ptr\n            });\n        }\n        ptr = skipVoid(toml, ptr);\n    }\n    return res;\n}\n"],
  "mappings": "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",
  "names": ["endPtr"]
}
